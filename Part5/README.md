# Part5
制作一个守护进程。本次只涉及怎么把一个进程变成守护进程。
## 具体步骤
### first fork()  
第一次fork后终止父进程留下子进程。如果从shell进入那么相当于该命令执行
完毕（所以还有不从shell进入的程序嘛？）。  
子进程继承了父进程的**进程组ID**，拥有自己的进程ID,**保证了子进程不是一个进程组的头进程**。
也是保证调用`setsid`的必要条件。  
### setsid  
该函数是一个`POSIX`函数，用于创建新的会话(`session`)。当前进程会变为新会话的
会话头进程以及新进程组的进程组头进程。  
（第一次fork保证了子进程不是一个进程组的头进程，但是这里让进程变成了进程组头进程，
是因为必须是非进程组头进程才可以变成一个进程组头进程？  
以及我们在第一次fork的时候，由于不能保证父进程是一个进程组的头进程，所以才需要创建一个？）  
### 忽略掉SIGHUP信号  
SIGHUP(signal hang up)在一个进程的控制终端被关闭时候发送。所以这里就需要了解一下SIGHUP。讲起之前
我们需要了解`进程组`和`会话`这俩概念。  
- 进程组  
进程组是一系列相互关联的进程集合，每个进程必须属于某进程组.每个进程组都有唯一PGID(process group id).PGID 一般等于进程组创建进程的 Process ID，而这个进进程一般也会被称为进程组头进程(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程。进程组的存在，方便了系统对多个相关进程执行某些统一的操作。例如，我们可以一次性发送一个信号量给同一进程组中的所有进程。
- 会话  
会话（session）是若干进程组的集合。每个进程组必须属于某一个会话。一个会话只拥有**最多一个控制终端**（也可以没有），该终端为会话中所有进程组的进程所共用。**一个会话中前台进程组只会有一个**，只有其中的进程才可以和控制终端进行交互。除了前台进程组外的进程组，都是后台进程组；和进程组先导类似，会话中也有会话头(session leader)的概念，用来表示建立起到控制终端连接的进程。  
在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)；

- SIGHUP  
好的，了解完之后。目光转向SIGHUP:SIGHUP 信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联. 系统对SIGHUP信号的**默认处理是终止收到该信号的进程**。所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出。  
那么什么时候SIGHUP会被触发呢？  
    - 终端关闭时，该信号被发送到session首进程以及作为job提交的进程（即用 & 符号提交的进程）；
　　- session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程；
　　- 若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程。

综上所述，我们肯定要忽略掉SIGHUP，不然我们的子程序就会在控制终端执行的时候被自动退出了。  
### 再次fork
再次fork的目的是确保再次打开一个控制终端的时候，进程不能自动获得一个控制终端。
### 改变工作目录
需要把工作目录改到根目录去，否则就无法在不对其所在的文件系统采取强制措施的情况下进行操作。
### 关闭所有打开的描述符
需要关闭掉该进程从执行他的进程（通常是shell）继承来的所有打开着的描述符。
（继承描述符是干嘛的，为什么要继承描述符）
### 重定向
将`stdio`,`stdout`,`stderr`重定向到`/dev/null`。重定向后，守护进程即使调用标准输入输出等库函数不会因为描述符未打开而失败。